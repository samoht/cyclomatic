<!-- This file is auto-generated by bin/generate_style_guide.ml -->
<!-- Do not edit manually. Edit lib/guide.ml instead. -->

# OCaml Coding Style Guide

This document outlines the coding and testing conventions for this project. The goal is to ensure the codebase is clear, robust, and maintainable. The style is inspired by the best practices of the modern OCaml ecosystem, emphasizing modularity and pragmatism.

## Core Philosophy

1. **Interface-First Design**: Always start by designing the module's interface in the `.mli` file. A clean interface is more critical than a clever implementation.

2. **Modularity**: Build small, focused modules that do one thing well. Compose them to build larger systems.

3. **Simplicity and Clarity (KISS)**: Prioritize clarity over conciseness. Strive for the simplest possible solution and avoid overly clever or obscure constructs.

4. **Explicitness**: Make control flow and error handling explicit. Avoid exceptions for recoverable errors.

5. **NEVER USE Obj.magic**: The `Obj` module is not part of the OCaml language and breaks type safety. There is always a better, type-safe solution.

### [E100] Unsafe Type Casting

This issue means you're using unsafe type casting that can crash your
program. Fix it by replacing Obj.magic with proper type definitions,
variant types, or GADTs to represent different cases safely.

## Dependencies and Tooling

**Build System**: The project is built exclusively with `dune`.

**Formatting**: All code is formatted automatically with `ocamlformat`. Run `dune fmt` before committing. Ensure you have a `.ocamlformat` file in your project root.

### [E500] Missing Code Formatter

This issue means your project lacks consistent code formatting. Fix it by
creating a .ocamlformat file in your project root with 'profile = default'
and a version number to ensure consistent formatting.

**Core Libraries**: Projects typically embrace a curated set of high-quality libraries for common tasks. For example:

- **Concurrency**: `eio`

- **Structured Output**: `fmt` (instead of Printf/Format)

### [E205] Outdated Printf/Format Modules

This issue means you're using outdated Printf/Format modules for
formatting. Fix it by switching to the modern Fmt module: add 'fmt' to your
dune dependencies and replace Printf/Format functions with Fmt
equivalents.

**Examples:**

❌ **Bad:**
```ocaml
let error_msg = Printf.sprintf "Error: %s at line %d" msg line
let () = Printf.printf "Processing %d items...\n" count
```

✅ **Good:**
```ocaml
let error_msg = Fmt.str "Error: %s at line %d" msg line
let () = Fmt.pr "Processing %d items...@." count

(* Even better with custom formatters *)
let pp_error ppf (msg, line) = 
  Fmt.pf ppf "Error: %s at line %d" msg line
```


- **Regular Expressions**: `re` (instead of Str module)

### [E200] Outdated Str Module

This issue means you're using the outdated Str module for regular
expressions. Fix it by switching to the modern Re module: add 're' to your
dune dependencies and replace Str functions with Re equivalents.

- **Logging**: `logs`

- **CLI Parsing**: `cmdliner`

- **JSON Handling**: `yojson`

- **HTTP**: `cohttp-eio`

- **Test Framework**: `Alcotest`

## Module and Interface Design

**Documentation**: Every `.mli` file must begin with a top-level documentation comment explaining its purpose. Focus on *what* the module provides, not *how* it is implemented.

### [E400] Missing Module Documentation

This issue means your modules lack documentation making them hard to
understand. Fix it by adding module documentation at the top of .mli files
with a brief summary and description of the module's purpose.

```ocaml
(** User API

    This module provides types and functions for interacting with users. *)
```

**Interface (`.mli`) Style**: Document every exported value. Use a consistent, concise style.

### [E405] Missing Value Documentation

This issue means your public functions and values lack documentation making
them hard to use. Fix it by adding documentation comments that explain what
each function does, its parameters, and return value.

**Documentation Philosophy**: For functions, use the `[function_name arg1 arg2] is ...` pattern.

```ocaml
val is_bot : t -> bool
(** [is_bot u] is [true] if [u] is a bot user. *)
```

For values, describe what the value represents.

```ocaml
type id = string
(** A user identifier. *)
```

**Abstract Types**: Keep types abstract (`type t`) whenever possible. Expose smart constructors and accessors instead of record fields to maintain invariants.

**Standard Interfaces for Data Types**: For modules defining a central data type `t`, consistently provide these functions where applicable:

### [E415] Missing Standard Functions

This issue means your types lack standard functions making them hard to use
in collections and debugging. Fix it by implementing equal, compare, pp
(pretty-printer), and to_string functions for your types.

- `val v : ... -> t`: A pure, smart constructor for creating values of type `t` in memory. This function should not perform any I/O.

- `val create : ... -> (t, Error.t) result`: A function that performs a side-effect, like an API call, to create a resource.

- `val pp : t Fmt.t`: A pretty-printer for logging and debugging.

- `val equal : t -> t -> bool`: A structural equality function.

- `val compare : t -> t -> int`: A comparison function for sorting.

- `val of_json : Yojson.Safe.t -> (t, string) result`: For parsing from JSON.

- `val to_json : t -> Yojson.Safe.t`: For serializing to JSON.

- `val validate : t -> (t, string) result`: For validating the integrity of the data.

## Project Structure

**Interface Files**: Create `.mli` files for all public modules to define clear interfaces and hide implementation details.

### [E505] Missing Interface Files

This issue means your modules lack interface files making their public API
unclear. Fix it by creating .mli files that document which functions and
types should be public. Copy public signatures from the .ml file and remove
private ones.

**Code Formatting**: Maintain a `.ocamlformat` file in the project root with consistent formatting settings.

### [E500] Missing Code Formatter

This issue means your project lacks consistent code formatting. Fix it by
creating a .ocamlformat file in your project root with 'profile = default'
and a version number to ensure consistent formatting.

## Command-Line Applications

For command-line applications in the `bin/` directory, it's common to use a library like `Cmdliner`.

**Shared Functionality**: Common functionality, such as authentication and logging setup, can be placed in a shared module (e.g., `bin/common.ml`).

**`run` function**: A shared module might provide a `run` function that initializes the application's main loop and environment (e.g., an Eio loop). This should be used by all commands to ensure a consistent environment.

## Error Handling

We use the `result` type for all recoverable errors. Exceptions are reserved for programming errors (e.g., `Invalid_argument`).

**Central Error Type**: Define a single, comprehensive error type for the library (e.g., in `lib/error.ml`).

```ocaml
(* In lib/error.mli *)
type t = [
  | `Api of string * Yojson.Safe.t (* code, fields *)
  | `Json_parse of string
  | `Network of string
  | `Msg of string
]

val pp : t Fmt.t
```

**Error Helpers**: In implementation files, use helper functions to construct errors. This ensures consistency.

```ocaml
(* In an implementation file *)
let err_api code fields = Error (`Api (code, fields))
let err_parse msg = Error (`Json_parse msg)

let find_user_id json =
  match Yojson.Safe.Util.find_opt "id" json with
  | Some (`String id) -> Ok id
  | Some _ -> err_parse "Expected string for user ID"
  | None -> err_parse "Missing user ID"
```

**No Broad Exceptions**: Never use `try ... with _ -> ...`. Always match on specific exceptions.

### [E105] Catch-All Exception Handlers

This issue means you're catching all exceptions which can hide bugs. Fix it
by replacing catch-all handlers with specific exception patterns and add
explicit handlers for each expected exception type.

**No Silenced Warnings**: Fix underlying issues instead of silencing compiler warnings with attributes like `[@warning "-nn"]`.

### [E110] Silenced Compiler Warnings

This issue means you're hiding compiler warnings that indicate potential
problems. Fix it by removing warning silencing attributes and addressing
the underlying issues that trigger the warnings.

**Initialization Failures**: For unrecoverable errors during startup (e.g., missing configuration), it is acceptable to fail fast using `Fmt.failwith`.

```ocaml
let tls_config =
  match Tls.Config.client ~authenticator () with
  | Ok config -> config
  | Error (`Msg msg) -> Fmt.failwith "Failed to create TLS config: %s" msg
```

## Naming and Formatting

**File Naming**: Lowercase with underscores (e.g., `user_profile.ml`).

**Module Naming**: Lowercase with underscores (e.g., `user_profile`).

### [E305] Module Naming Convention

This issue means your module names don't follow OCaml naming conventions.
Fix them by renaming to lowercase_with_underscores (e.g., MyModule → my_module).

**Type Naming**: The primary type in a module is `t`. Identifiers are named `id`. Use snake_case for all type names.

### [E315] Type Naming Convention

This issue means your type names don't follow OCaml naming conventions. Fix
them by renaming to snake_case (e.g., myType → my_type).

**Variant Constructors**: Use Snake_case for variant constructors (e.g., `Waiting_for_input`, `Processing_data`), not CamelCase.

### [E300] Variant Naming Convention

This issue means your variant constructors don't follow OCaml naming
conventions. Fix them by renaming to Snake_case (e.g., MyVariant →
My_variant).

**Examples:**

❌ **Bad:**
```ocaml
type status = 
  | WaitingForInput    (* CamelCase *)
  | ProcessingData
  | errorOccurred      (* lowerCamelCase *)
```

✅ **Good:**
```ocaml
type status = 
  | Waiting_for_input  (* Snake_case *)
  | Processing_data
  | Error_occurred
```


**Values**: Short, descriptive, and lowercase with underscores (e.g., `find_user`, `create_channel`).

### [E310] Value Naming Convention

This issue means your value names don't follow OCaml naming conventions.
Fix them by renaming to snake_case (e.g., myValue → my_value).

**Long Identifiers**: Avoid excessively long names with many underscores. Keep names concise and meaningful.

### [E320] Long Identifier Names

This issue means your identifier has too many underscores making it hard to
read. Fix it by removing redundant prefixes and suffixes:

• In test files: remove 'test_' prefix (e.g., test_check_foo → check_foo or
  just foo)
• In hint files: remove '_hint' suffix (e.g., complexity_hint → complexity)
• In modules: remove '_module' suffix (e.g., parser_module → parser)
• Remove redundant words that repeat the context (e.g., check_mli_doc →
  check_mli)

The file/module context already makes the purpose clear.

**Function Naming**: Use `get_*` for extraction (returns value directly), `find_*` for search (returns option type).

### [E325] Function Naming Pattern

This issue means your function names don't match their return types. Fix
them by using consistent naming: get_* for extraction (returns value
directly), find_* for search (returns option type).

**Labels**: Use labels only when they clarify the meaning of an argument, not for all arguments. Avoid `~f` and `~x`.

**Formatting**: Trust `ocamlformat`. No manual formatting.

## Function Design

**Keep Functions Small and Focused**: A function should do one thing well. Decompose complex logic into smaller, well-defined helper functions. This improves readability, testability, and reusability. Aim for functions under 50 lines. As a rule of thumb, avoid deep nesting of `match` or `if` statements; more than two or three levels is a strong signal that the function should be refactored.

### [E005] Long Functions

This issue means your functions are too long and hard to read. Fix them by
extracting logical sections into separate functions with descriptive names.
Note: Functions with pattern matching get additional allowance (2 lines per case).
Pure data definitions (lists, records) are also exempt from length checks.
For better readability, consider using helper functions for complex logic.
Aim for functions under 50 lines of actual logic.

### [E010] Deep Nesting

This issue means your code has too many nested conditions making it hard to
follow. Fix it by using pattern matching, early returns with 'when' guards,
or extracting nested logic into helper functions.

**Complexity Management**: Break down functions with high cyclomatic complexity into smaller, focused helper functions with clear names.

### [E001] High Cyclomatic Complexity

This issue means your functions have too much conditional logic. Fix them
by extracting complex logic into smaller helper functions with clear names
that describe their purpose.

**Examples:**

❌ **Bad:**
```ocaml
let process_data data user =
  if data.valid then
    if user.authenticated then
      if data.size < 1000 then
        if has_permission user data then
          (* complex processing logic *)
        else Error "No permission"
      else Error "Data too large"
    else Error "Not authenticated"
  else Error "Invalid data"
```

✅ **Good:**
```ocaml
let validate_data data = 
  if not data.valid then Error "Invalid data" else Ok ()

let check_auth user = 
  if not user.authenticated then Error "Not authenticated" else Ok ()

let check_size data = 
  if data.size >= 1000 then Error "Data too large" else Ok ()

let check_permission user data = 
  if not (has_permission user data) then Error "No permission" else Ok ()

let process_data data user =
  let open Result.Syntax in
  let* () = validate_data data in
  let* () = check_auth user in
  let* () = check_size data in
  let* () = check_permission user data in
  (* complex processing logic *)
```


**Purity**: Prefer pure functions. Isolate side-effects (I/O, state mutation) at the edges of the application, primarily in the `bin/` and `lib/ui/` directories.

**Composition over Abstraction**: Favor the composition of small, concrete functions to build up complex behavior. Avoid deep abstractions and complex class hierarchies.

**Data-Oriented Design**: Design functions to operate on simple, immutable data structures (records, variants, etc.). Avoid creating complex objects with hidden internal state.

**Avoid Premature Generalization**: Write code that solves the problem at hand. Avoid adding unnecessary complexity or generality that is not required by the current needs of the project.

## Logging

Effective logging is crucial for debugging and monitoring. We use the `logs` library for all logging.

**Log Source**: Each module should define its own log source.

```ocaml
let log_src = Logs.Src.create "project_name.module_name"
module Log = (val Logs.src_log log_src : Logs.LOG)
```

**Log Levels**: Use the following log levels appropriately:

- `Log.app`: For messages that should always be shown to the user (e.g., startup messages).

- `Log.err`: For errors that have been handled but are critical enough to report.

- `Log.warn`: For potential issues that do not prevent the current operation from completing.

- `Log.info`: For informational messages about the application's state.

- `Log.debug`: For detailed, verbose messages useful for debugging.

**Structured Logging**: Use tags to add structured context to log messages. This is especially useful for machine-readable logs.

```ocaml
Log.info (fun m ->
    m "Received event: %s" event_type
      ~tags:(Logs.Tag.add "channel_id" channel_id Logs.Tag.empty))
```

## Testing

## Core Testing Philosophy

1. **Unit Tests First**: Prioritize unit tests for individual modules and functions.

2. **1:1 Test Coverage**: Every module in `lib/` should have a corresponding test module in `test/`.

### [E605] Missing Test Coverage

This issue means some of your library modules lack test coverage making
bugs more likely. Fix it by creating corresponding test files for each
library module to ensure your code works correctly.

### [E610] Orphaned Test Files

This issue means you have test files that don't correspond to any library
module making your test organization confusing. Fix it by either removing
orphaned test files or creating the corresponding library modules.

3. **Test Organization**: Test files should export a `suite` value.

### [E600] Test Module Convention

This issue means your test files don't follow the expected convention for
test organization. Fix it by exporting a 'suite' value instead of running
tests directly, allowing better test composition and organization.

4. **Test Inclusion**: All test suites must be included in the main test runner.

### [E615] Excluded Test Suites

This issue means some test suites aren't included in your main test runner
so they never get executed. Fix it by adding them to the main test runner
to ensure all tests are run during development.

5. **Clear Test Names**: Test names should describe what they test, not how.

6. **Isolated Tests**: Each test should be independent and not rely on external state.

## Test Structure

**`test/test.ml`**: A main test runner that aggregates test suites from individual `test_*.ml` files.

**`test/test_*.ml`**: Each `test_*.ml` file contains the tests for a specific module.

**`test/dune`**: Defines the test executable.

**Individual Test Files**: Each `test_*.ml` file should export a `suite` value of type `(string * Alcotest.test_case list) list`.

**Test Naming Convention**:

- Test suite names should be lowercase, single words (e.g., `"users"`, `"commands"`)

- Test case names should be lowercase with underscores, concise but descriptive (e.g., `"list"`, `"create"`, `"parse_error"`)

## Writing Good Tests

**Function Coverage**: Test all public functions exposed in `.mli` files, including success, error, and edge cases.

**Test Data**: Use helper functions to create test data.

**Property-Based Testing**: For complex logic, consider property-based testing with QCheck.

## End-to-End Testing with Cram

Cram tests are essential for verifying the behavior of the final executable.

**Use Cram Directories**: Every Cram test should be a directory ending in `.t` (e.g., `my_feature.t/`).

**Create Actual Test Files**: Avoid embedding code within the `run.t` script using `cat > file << EOF`. Create real source files within the test directory.

## Running Tests

```ocaml
# Run all tests
dune test

# Run tests and watch for changes
dune test -w

# Run tests with coverage
dune test --instrument-with bisect_ppx
bisect-ppx-report summary
```

## Commit Messages

We follow a structured format for commit messages to ensure they are clear, informative, and easy to read. A good commit message provides context for why a change was made.

## Format

A commit message consists of a short, imperative title followed by a more detailed body.

**Title**: A single, concise line summarizing the change.

- Keep it under 50 characters.

- Use the imperative mood (e.g., "Add feature" not "Added feature")

- Do not end the title with a period.

**Body**: A detailed explanation of the change, separated from the title by a blank line.

- Wrap the body at 72 characters.

- The body should be structured into paragraphs that implicitly answer three questions:

  1. **What** does this change do?

  2. **Why** was this change necessary?

  3. **How** was this change implemented?

## Example

```ocaml
feat(parser): Add support for parsing logical operators

This change introduces the capability to parse logical `AND` and `OR`
operators in the expression language. It extends the lexer to
recognize `&&` and `||` and updates the parser with new rules for
logical expressions.

The expression language previously lacked support for combining
conditions, which was a significant limitation for writing complex
business rules. This feature was requested by users to allow for more
flexible and powerful queries.

The implementation involved extending the lexer's token set with `AND`
and `OR` tokens and updating the parser's precedence rules. New AST
nodes for `LogicalAnd` and `LogicalOr` were added, and the evaluator
was updated to handle them.
```

## AI Assistants

AI assistants may be used to help write code, but the final commit must be authored by a human developer. Do not use `Co-authored-by:` trailers for AI assistants.
